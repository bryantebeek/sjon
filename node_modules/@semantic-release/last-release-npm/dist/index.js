'use strict';

var _error = require('@semantic-release/error');

var _error2 = _interopRequireDefault(_error);

var _npmRegistryClient = require('npm-registry-client');

var _npmRegistryClient2 = _interopRequireDefault(_npmRegistryClient);

var _npmlog = require('npmlog');

var _npmlog2 = _interopRequireDefault(_npmlog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (pluginConfig, _ref, cb) {
  var pkg = _ref.pkg,
      npm = _ref.npm,
      plugins = _ref.plugins,
      options = _ref.options;

  _npmlog2.default.level = npm.loglevel || 'warn';
  var clientConfig = { log: _npmlog2.default };
  // disable retries for tests
  if (pluginConfig && pluginConfig.retry) clientConfig.retry = pluginConfig.retry;
  var client = new _npmRegistryClient2.default(clientConfig);

  client.get('' + npm.registry + pkg.name.replace('/', '%2F'), {
    auth: npm.auth
  }, function (err, data) {
    var isNotFound = err && (err.statusCode === 404 || /not found/i.test(err.message));
    var isCompletelyUnpublished = data && !data['dist-tags'];

    if (isNotFound || isCompletelyUnpublished) {
      return cb(null, {});
    }

    if (err) return cb(err);

    var distTags = data['dist-tags'];
    var version = distTags[npm.tag];

    if (!version && options && options.fallbackTags && options.fallbackTags[npm.tag] && distTags[options.fallbackTags[npm.tag]]) {
      version = distTags[options.fallbackTags[npm.tag]];
    }

    if (!version) {
      return cb(new _error2.default('There is no release with the dist-tag "' + npm.tag + '" yet.\nTag a version manually or define "fallbackTags".', 'ENODISTTAG'));
    }

    cb(null, {
      version: version,
      gitHead: data.versions[version].gitHead,
      get tag() {
        _npmlog2.default.warn('deprecated', 'tag will be removed with the next major release');
        return npm.tag;
      }
    });
  });
};